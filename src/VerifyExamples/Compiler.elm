module VerifyExamples.Compiler exposing (compile)

import Regex exposing (HowMany(..), regex)
import String
import String.Extra
import VerifyExamples.Ast exposing (..)


compile : String -> List TestSuite -> String
compile moduleName suites =
    let
        filteredSuites =
            List.filter (.tests >> List.isEmpty >> not) suites
    in
    String.join "\n" <|
        List.concat
            [ moduleHeader moduleName
                (List.concatMap .imports suites)
                (List.concatMap .types suites)
            , spec moduleName filteredSuites
            ]


moduleHeader : String -> List String -> List String -> List String
moduleHeader moduleName imports types =
    [ "module Doc." ++ moduleName ++ "Spec exposing (spec)"
    , ""
    , "-- This file got generated by [elm-verify-examples](https://github.com/stoeffel/elm-verify-examples)."
    , "-- Please don't modify this file by hand!"
    , ""
    , "import Test"
    , "import Expect"
    , "import " ++ moduleName ++ " exposing(..)"
    , ""
    ]
        ++ imports
        ++ [ "" ]
        ++ types


spec : String -> List TestSuite -> List String
spec moduleName suites =
    let
        renderedSuites =
            List.indexedMap toDescribe suites
                |> List.concat
    in
    [ ""
    , ""
    , "spec : Test.Test"
    , "spec ="
    , indent 1 "Test.describe \"" ++ escape moduleName ++ "\" <|"
    ]
        ++ [ indent 1 "[" ]
        ++ List.map (indent 2) renderedSuites
        ++ [ indent 1 "]" ]


toDescribe : Int -> TestSuite -> List String
toDescribe index suite =
    let
        renderedTests =
            List.indexedMap toTest suite.tests
                |> List.concat
    in
    (addCommaIfNotFirstItem index
        ++ "Test.describe \""
        ++ (suite.functionToTest
                |> Maybe.map ((++) "#")
                |> Maybe.withDefault ("Comment: " ++ toString (index + 1))
                |> escape
           )
        ++ "\" <|"
    )
        :: List.map (indent 1) (toLetIns suite.helperFunctions)
        ++ [ indent 1 "[" ]
        ++ List.map (indent 1) renderedTests
        ++ [ indent 1 "]" ]


toTest : Int -> Test -> List String
toTest index test =
    [ indent 0
        (addCommaIfNotFirstItem index
            ++ "Test.test \""
            ++ "Example: "
            ++ toString (index + 1)
            ++ " -- "
            ++ exampleName test
            ++ "\" <|"
        )
    , indent 1 "\\() ->"
    , indent 2 "Expect.equal"
    , indent 3 "("
    ]
        ++ (List.map (indent 4) <| String.lines test.assertion)
        ++ [ indent 3 ")"
           , indent 3 "("
           ]
        ++ (List.map (indent 4) <| String.lines test.expectation)
        ++ [ indent 3 ")"
           ]


exampleName : Test -> String
exampleName test =
    (test.assertion ++ " --> " ++ test.expectation)
        |> String.Extra.replace "\n" " "
        |> String.Extra.clean
        |> String.Extra.ellipsis 40
        |> String.Extra.surround "`"
        |> escape


toLetIns : List Function -> List String
toLetIns fns =
    case List.filter .isUsed fns of
        [] ->
            []

        usedFns ->
            indent 0 "let"
                :: List.concatMap (List.map (indent 1) << String.lines << .value) usedFns
                ++ [ indent 0 "in"
                   ]


addCommaIfNotFirstItem : Int -> String
addCommaIfNotFirstItem index =
    if index == 0 then
        ""
    else
        ", "


indent : Int -> String -> String
indent count str =
    List.repeat (count * 4) " "
        ++ [ str ]
        |> String.join ""


escape : String -> String
escape =
    Regex.replace All (regex "\\\\") (\_ -> "\\\\")
        >> Regex.replace All (regex "\\\"") (\_ -> "\\\"")
        >> Regex.replace All (regex "\\s\\s+") (\_ -> " ")
