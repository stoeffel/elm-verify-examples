module VerifyExamples.Compiler exposing (compile)

import String
import String.Extra exposing (clean, ellipsis, replace, surround, toSentenceCase)
import String.Util exposing (escape, indent, unlines)
import VerifyExamples.Function exposing (Function)
import VerifyExamples.Test exposing (Test)
import VerifyExamples.TestSuite as TestSuite exposing (TestSuite)


type alias Info =
    { imports : List String
    , types : List String
    , helperFunctions : List Function
    , moduleName : String
    }


compile : String -> TestSuite -> List ( String, String )
compile moduleName suite =
    let
        info =
            { imports = suite.imports
            , types = suite.types
            , helperFunctions = suite.helperFunctions
            , moduleName = moduleName
            }
    in
    if TestSuite.notSpecial suite then
        [ ( moduleName
          , List.concat
                [ moduleHeader info Nothing
                , suite.tests
                    |> List.indexedMap compileTest
                    |> List.concat
                    |> addTodoIfEmpty
                ]
                |> unlines
          )
        ]
    else
        List.indexedMap (compileTestPerFunction info) suite.tests


compileTestPerFunction : Info -> Int -> Test -> ( String, String )
compileTestPerFunction info index test =
    let
        functionToTestWithIndex =
            test.functionToTest
                |> Maybe.map (flip (++) (toString index))
                |> Maybe.withDefault ("ModuleDoc" ++ toString index)
                |> Just
    in
    ( specModule info.moduleName functionToTestWithIndex
    , unlines <|
        List.concat
            [ moduleHeader info functionToTestWithIndex
            , info.types
            , [ "" ]
            , info.helperFunctions
                |> List.filter .isUsed
                |> List.map .value
            , [ "" ]
            , spec test index
            ]
    )


compileTest : Int -> Test -> List String
compileTest index test =
    spec test index


moduleHeader : Info -> Maybe String -> List String
moduleHeader { moduleName, imports } functionToTest =
    [ "module Doc." ++ specModule moduleName functionToTest ++ "Spec exposing (..)"
    , ""
    , "-- This file got generated by [elm-verify-examples](https://github.com/stoeffel/elm-verify-examples)."
    , "-- Please don't modify this file by hand!"
    , ""
    , "import Test"
    , "import Expect"
    , "import " ++ moduleName ++ " exposing(..)"
    , ""
    ]
        ++ imports
        ++ [ "" ]


specModule : String -> Maybe String -> String
specModule moduleName functionToTest =
    case functionToTest of
        Just function ->
            String.join "."
                [ moduleName, toSentenceCase function ]

        Nothing ->
            moduleName


spec : Test -> Int -> List String
spec test index =
    [ ""
    , ""
    , "spec" ++ toString index ++ " : Test.Test"
    , "spec" ++ toString index ++ " ="
    , indent 1 (testDefinition test)
    , indent 2 "\\() ->"
    , indent 3 "Expect.equal"
    ]
        ++ List.map (indent 4) (specBody test)


addTodoIfEmpty : List String -> List String
addTodoIfEmpty tests =
    case tests of
        [] ->
            todo

        _ ->
            tests


todo : List String
todo =
    [ ""
    , ""
    , "spec : Test.Test"
    , "spec ="
    , indent 1 "Test.todo \"add a doc test\""
    ]


testDefinition : Test -> String
testDefinition test =
    String.concat
        [ "Test.test \""
        , test.functionToTest
            |> Maybe.map ((++) "#")
            |> Maybe.withDefault "Module Doc"
        , " Example: "
        , exampleName test
        , "\" <|"
        ]


exampleName : Test -> String
exampleName { assertion, expectation } =
    (assertion ++ " --> " ++ expectation)
        |> replace "\n" " "
        |> clean
        |> ellipsis 40
        |> surround "`"
        |> escape


specBody : Test -> List String
specBody { assertion, expectation } =
    List.concat
        [ [ "(" ]
        , String.lines assertion
        , [ ")", "(" ]
        , String.lines expectation
        , [ ")" ]
        ]
